---
layout:    post
title:     "网络基础知识简介"
subtitle:   " \"每一个前端需要了解的知识\""
date:       2017/08/13
author:     "CaoFan"
header-img: "img/post-bg-internet.jpg"
catalog: true
tags:
  - 网络

---

>"Internet"

## 前言 

前几天在掘金上看了大漠老师写的一篇[文章](https://juejin.im/entry/598d503d6fb9a03c48450f77),
他在这里讲了作为一个前端工程师需要掌握的技术，当然html,css
,javascript是必须要掌握的，那么对于网络协议来说也是必须的，他会让我们变得更加强大，然而网络也只是冰山一角，任重而道远，一起进步！

## 正文
### 1.对于我们前端工程师来说，为什么要学会网络呢？   
前端所编写的代码，js，html和css都属于客户端的语言，我们一定会需要服务器端来为我们传递大量的数据，在这中间必然会有大量的错误出现，学习网络协议能够让我们找到错误是出现在我们前端还是后端，大大提高了解决问题的效率。

### 2.开始学习
#### 网络七层模型（OSI模型）    
* **物理层模型**     
* **数据链路层**    
* **网络层**      
* **传输层**      
* **会话层**    
* **表示曾**      
* **应用层**     
#### TCP/IP四层划分（从最底到最上层）  
为什么少那两层，是因为他们没有TCP/IP协议。每一层为了完成各自特定的功能都需要遵守规则，这些规则就是`协议`。      
**1.数据链路层**             
+ 在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。(真的看萌了，哈哈)————[维基百科](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82)    
只能用自己的大白话理解一下：就是说两个手机之间数据传送的创建，并且保持链接，最后断开链接的一套。
+ 其中的`以太网协议`：一组电信号构成一个数据包，叫做“帧”(Frame)。每一帧分为：标头(Head)和数据(Data)。       
标头(Head)：包含数据包的一些说明项，比如发送者、接受者、数据类型等等；标头的长度，固定为18字节。       
数据(Data):数据则是数据包的具体内容;数据的长度，最短为46字节，最长为1500字节。      
整个帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。    
+ MAC地址：[网卡](https://zh.wikipedia.org/wiki/%E7%BD%91%E5%8D%A1)的地址就是数据包的发送地址和接受地址。每块网卡都有自己独一无二的MAC地址。MAC地址可以定位网卡和数据包的路径。      
+ 广播：以太网采用广播的方式寻找接受者的MAC地址，即放松这发送的数据包会发送给本网络内所有的计算机，然后由接收搭配数据包的计算机自己来判断是不是接收方。(不同子网络广播是行不通的)。       
**2.网络层**          
+ 提供路由(对于不同网络之间的相互通信需要借助路由)和寻址(网络层依靠IP地址进行相互通信)功能。引进一套新地址，使我们能够区分不同计算机是否属于同一个子网络，这套新地址即为“网址”(这样每台电脑就有了两个地址，MAC不变的地址和后期管理员分配的可变的网络地址)。     
+ 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。      
+ 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的所用就是在众多的选项内选择一条传输路线。    
**3.传输层**       
+ 该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。————[维基百科](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82)        
+ 传输层对应用层，提供处于网络连接中两台计算机之间的数据传输。       
**4.应用层**     
+ 应用层直接和应用程序接口并提供常见的网络应用服务。—————[维基百科](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82)
+ TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Proto3col，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中的两类。HTTP协议也处于该层。       
#### 前端需要更加了解的点       
对于我们前端开发人员来说，最主要的是与服务器的链接，因为我们有大量的数据需要传输
首先我们要了解一下，最简单的提交数据的方式就是<form>表单，但是它的用户体验不好，每次提交都会刷新页面，所以后来就出现的ajax，无页面刷新。       

##### 1.<form>表单     
其中有一个属性metohd，它规定用于发送 form-data 的 HTTP 方法。两种方法：post，get，那他们有哪些区别呢？      

> ① GET是使用URL或者cookie传参（用&符号连接参数）。   
  ② GET的URL会有长度上的限制，POST可以传输很多数据。     
  ③ 根据第一条来看，POST比GET相对安全。      
  补充：     
  但是其实对于HTTP协议来说，并没有规定POST的数据就要放到BODY里面，也没有规定GET数据一定要放到URL里面；同时也没有对它们传输数据的长度进行限制，两方面原因造成了这些：   
  1）早期浏览器会对URL长度进行限制，所以导致了GET数据的限制。     
  2）浏览器会对Content-lengt进行限制，这是为了服务器安全和稳定。    

##### 2.AJAX(Asynchronous javascript and xml)：用javascript以异步的形式操作xml/json。     
1.优点：   
+ 页面无刷新，在页面内与服务器进行通信，用户体验好。     
+ 使用异步的形式与服务器进行听信，不会打断用户的其它操作，用户体验好。    
+ 不需要其他的插件。     
+ 减轻服务器的负担。     

2.缺点：
+ 不支持浏览器的后退机制。     
+ 不支持移动设备。     
+ 安全问题。     
+ 违背了url和资源定位的初衷。   

3.AJAX两个重要的对象：    
+ new XMLHttpRequest() 主流浏览器，        
+ new ActiveXObject('Microsoft.XMLHTTP') IE6以下。         

4.AJAX对象的三个重要的方法：      
+ .open('method', 'url', 'true') :建立和服务器的连接，method是传参的方式post或者get。url可以是相对地址也可以是绝对地址。第三个参数是选择同步还是异步，true为异步。     
+ .send(data)：向服务器发送请求。      
+ .setRequestHeader('label', 'value')：把指定首部设置为提供的值，在设置任何首部之前必须调用open方法。     

5.AJAX对象的一些属性：       
+ onreadystatechange: 状态改变触发器       
+ readyState：对象的状态       
0 代表初始化，此时已经创建了XMLHttpRequest对象。       
1 代表读取中，此时代码已经调用了open方法并且已经发送到服务器。      
2 代表已读取，open方法把一个请求发送到服务器，但是还没有收到。      
3 代表交互中，已经收到http响应头部信息，但是消息主体部分还没有完全接收。      
4 代表完成。        
+ responseText 服务器返回数据的文本版本      
+ status 服务器返回的状态码       
 
6.自己封装ajax：     


    function Ajax(method, url, flag, calback, data) {
      var xhr = null;
      if(window.XMLHttpRequest) {
        xhr = new window.XMLHttpRequest();
      }else {
        xhr = new ActiveXObject('Microsofot.XMLHTTP')
      }
      if(method === 'GET') {
        xhr.open('GET', url + '?' + data, flag);
        xhr.send();
      }else if(method === "POST") {
        xhr.open('POST', url, flag);
        xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
        xhr.send(data);
      }
      xhr.onreadystatechange = function () {
        if(xhr.readyState == 4) {
          if(xhr.status == 200) {
            callback(xhr.responseText);
          }
        }
      }
    }

7.补充：ajax各浏览器中申请本地资源的区别。        
由于浏览器安全问题：
>1) js不允许访问本地文件       
2) ajax请求也不能访问跨域的页面       
3) firefox下端口不一致也会导致跨域         

不同浏览器对ajax访问本地文件的支持：       
> 1) webkit核心的浏览器：如Chrome，只能访问自己（或者可以访问其他域名的页面，此页面设置过Access-Control-Allow-Origin=*响应头允许跨域请求），无法访问其他本地资源。ajax.html只请求能访问ajax.html，不能请求同文件夹下的其他文件及上级目录下的文件。       
2) Gecko核心的浏览器：如firefox，可以访问同级目录下的所有文件和子文件，但是不能访问上一级目录的文件。否则会报“Access to restricted URI denied”的错误。           
3) trident核心的浏览器：如IE，不能使用XMLHttpRequest,使用ActiveXObject创建的ajax对象则没有限制。      

#### 3.HTTP协议简单了解    
HTTP（HyperText Transfer Protocol）超文本传输协议，所有的www文件都必须遵守这个标准。    
HTTPS（HyperText Transfer Protocol over Secure Socket Layer）,安全版的HTTP。  
**主要特点：**     
1.**支持客户端或者服务器端**      
2.**简单快速**：客户端向服务器发送请求时，只需要传送请求方法和路径。常用方法：GET\HEAD\POST；由于HTTP协议简单，使得HTTP服务器规模小，通信速度快。     
3.**灵活**：HTTP允许传输任意类型的数据。传输的数据类型由Content-type加以标记。    
4.**无连接**：限制每次连接只处理一个请求。服务器处理完客户端的请求，收到应答后，即断开连接，这样可以节省传输时间。      
5.**无状态**：指HTTP协议对于事务处理没有记忆能力。这意味着后期需要处理前期的信息，则必须重新传输，这样导致每次连接传输的数据量增大。另外当服务器不需要处理前期信息的时候应答就较快。    
注：**持续连接**：HTTP1.1出现了持久连接以节省通信量，建立一次TCP连接之后可以进行多次请求和响应的交互。_特点_是只要任意一端没有明确提出断开连接，则保持TCP连接状态；_优点_是减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负荷；_不足_只有HTTP1.1才支持，并且只有GET和HEAD方式可以使用，POST有所限制。

**HTTP通信报文**
* 请求报文：   
请求头: http://webcaofan.com/http_header     
请求行：请求方法(GET,POST,HEAD,PUT,DELETE,OPTION) 请求url 协议版本 ；这个格式。       
请求主体：对于表单提交数据（name=caofan&&age=21;）     
![img](/img/in-post/internet-article/request.png)
Accept: 请求报文域用于制定客户端接受哪些类型的信息。    
Accept-language：指定一种自然语言。    
Referer: 用来表示从哪儿链接到目前的网页。    
User-Agent：用来互殴浏览器的名称和版本。      
Cotent-type：传输数据的类型。     
HOST：用于指定被请求资源的网络主机和端口号。   
Content-length：指明主体的长度，以字节方式储存的十进制数字来表示。     
Connection： 决定当前事务完成后，是否会关闭网络连接，'keep-alive表示永久连接'。       
Cache-Control: 是否支持缓存。   


* 响应报文：      
响应头：http://webcaofan.com/http_header        
响应行：响应协议版本号(HTTP/1.1) 响应状态码(200) 响应状态文字(OK)        
响应主体：'成功'       
![img](/img/in-post/internet-article/answer.png)  
Server：包含了服务器用来处理请求的软件信息。       
Date：表示消息的生产日期和时间。       
transfer-encoding ：chunked表示报文采用了分块编码。      

**HTTP常见的状态码**      
1XX   （信息状态码），接收到请求正在处理       
2XX   （成功状态码），请求正确处理完毕        
200   服务器成功返回内容           
204   请求成功但是没有资源返回     
3XX   （重定向状态码），为了完成请求需要进行另一种措施(如从浏览器缓存获取资源，或者跳转到其他页面)        
301   永久重定向，表示请求的资源被永久移动到新的url                   
302   临时重定向，客户端应继续使用原有的url,禁止POST变成GET        
303   请求的资源存在着另外一个url,因使用GET方法定性获取资源          
304   资源已找到，但是未符合要求                  
4XX   （客户端错误状态码），请求语法有错误，不能完全符合        
400   请求报文中存在语法错误         
401   发送的请求需要通过HTTP认证信息        
403   不允许访问该资源                
404   请求内容不存在          
5XX   （服务器端错误状态码），服务器无法完成请求           
500   服务器在执行请求时发生错误        
503   服务器暂时处于超负荷工作或正在停机维修，无法请求                  
#### 4.客户端和服务器之间如何通信   
_首先当你在浏览器中输入一个url会发生什么？_       
简单来说就是：      
1.浏览器通过DNS域名解析成ip地址。     
2.浏览器通过TCP协议建立与服务器TCP连接(三次握手，四次挥手)。        
3.浏览器向服务器端发送HTTP协议包，请求服务器里的资源文档。        
4.服务器向浏览器端发送HTTP协议应答包。       
5.浏览器和服务器端断开连接，客户端开始解析html文档。      

> **三次握手：**      
  1.首先客户端(浏览器端)发送连接请求报文。      
  2.服务器端接受后回复ACK报文，并为这次连接分配资源。     
  3.客户端接收到ACK报文后也向服务器端发送ACK报文，并分配资源，这样就建立了TCP连接。       
  **四次挥手:**        
  1.客户端发送FIN报文给服务器端，发起中断请求，这时候客户端已没有数据给服务器端了，如果服务器端还有数据可以继续发送。       
  2.服务器端发送ACK报文，接受到客户端的请求了，还在准备，请继续等待。      
  3.当服务器端确定数据已发送完成，则向客户端发送FIN报文，表示所有数据全部发送完成了，可以关闭连接了。     
  4.客户端收到FIN报文后，发送ACK报文，进入等待状态，服务器端收到ACK报文后断开连接，客户端等待2ms后，没有收到回复，即关闭连接。         

* TCP和UDP的区别？     
`TCP`是基于连接的协议，在正式收发数据前，必须建立可靠的连接。一个TCP连接必须要经过三次‘对话’才能建立起来。            
`UDP`是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接把数据包放松过去。UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。        


#### 5.浏览器的缓存机制       
当客户端向服务器端发送请求时，会考虑资源有没有发生改变，如果没有取缓存，那么这个过程是怎么实现的呢？       
简单概述一下过程：     
> 第一次发送请求时，资源被标记e-tag，并且记录获取时间。      
  第二次发送请求时，服务器端会返回e-tag查看是否被缓存，再查看if-not-modified查看缓存资源有没有改过，最后通过last-modified记录此时对应资源的最新修改时间。  

请求头：   
if-None-Match: 表示匹配e-tag，如果它修改了，则不取缓存       
if-Modified：如果到了某个时间修改了，则不取缓存           
响应头：     
e-tag：标记图片资源，配合last-Modified使用       






